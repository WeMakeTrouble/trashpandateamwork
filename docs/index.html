<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trash Panda Teamwork</title>
    <style>
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; } body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 400px; margin: 0 auto; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; color: #333; } .container { background: white; border-radius: 20px; padding: 30px; box-shadow: 0 20px 40px rgba(0,0,0,0.1); } h1 { text-align: center; color: #4a5568; margin-bottom: 10px; font-size: 24px; } .subtitle { text-align: center; color: #666; font-size: 14px; margin-bottom: 30px; font-style: italic; } .setup-section { background: #e6f3ff; border-radius: 10px; padding: 20px; margin-bottom: 20px; border: 2px solid #4299e1; } .setup-section h3 { margin-top: 0; color: #2b6cb0; } .form-group { margin: 15px 0; } .form-group label { display: block; margin-bottom: 5px; font-weight: 600; color: #2d3748; } .form-group input { width: 100%; padding: 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 16px; -webkit-appearance: none; } .form-group input:focus { outline: none; border-color: #4299e1; } .save-config-btn { background: #4299e1; color: white; border: none; padding: 15px 20px; border-radius: 8px; cursor: pointer; font-size: 16px; width: 100%; margin-top: 10px; -webkit-appearance: none; } .voice-button { width: 120px; height: 120px; border-radius: 50%; border: none; background: linear-gradient(45deg, #ff6b6b, #ee5a52); color: white; font-size: 24px; cursor: pointer; margin: 20px auto; display: block; transition: all 0.3s ease; box-shadow: 0 5px 15px rgba(238, 90, 82, 0.4); opacity: 0.5; -webkit-appearance: none; } .voice-button.enabled { opacity: 1; } .voice-button.recording { background: linear-gradient(45deg, #4ecdc4, #44a08d); animation: pulse 1.5s infinite; } @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } } .transcript { background: #f8f9fa; border-radius: 10px; padding: 15px; margin: 20px 0; min-height: 80px; border: 2px dashed #e9ecef; font-size: 14px; } .transcript.has-content { border: 2px solid #4ecdc4; background: #f0fff4; } .status { text-align: center; margin: 15px 0; font-size: 14px; color: #666; font-weight: 500; } .extracted-tasks { background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 10px; padding: 15px; margin: 20px 0; display: none; } .extracted-tasks.show { display: block; } .task-item { background: white; padding: 12px; margin: 8px 0; border-radius: 8px; border-left: 4px solid #4ecdc4; } .task-item strong { color: #2d3748; } .send-sms-btn { background: #48bb78; color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 12px; margin-top: 8px; -webkit-appearance: none; } .send-sms-btn:disabled { background: #a0aec0; cursor: not-allowed; } .diary-entries { margin-top: 30px; } .diary-entry { background: #f8f9fa; border-radius: 10px; padding: 15px; margin: 10px 0; border-left: 4px solid #667eea; } .entry-date { font-size: 12px; color: #666; margin-bottom: 5px; } .clear-btn { background: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; font-size: 12px; margin-top: 10px; -webkit-appearance: none; } .sms-log { background: #d4edda; border: 1px solid #c3e6cb; border-radius: 10px; padding: 15px; margin: 20px 0; display: none; } .sms-log.show { display: block; } .sms-message { background: white; padding: 8px 12px; margin: 5px 0; border-radius: 5px; font-size: 13px; } .hidden { display: none; } .demo-note { background: #fff8dc; border: 1px solid #deb887; border-radius: 8px; padding: 15px; margin: 15px 0; font-size: 12px; color: #8b4513; } .success-message { background: #d4edda; border: 1px solid #c3e6cb; border-radius: 8px; padding: 15px; margin: 15px 0; color: #155724; font-size: 14px; } .error-message { background: #fee; border: 1px solid #fcc; border-radius: 8px; padding: 15px; margin: 15px 0; color: #c33; font-size: 14px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü¶ù Trash Panda Teamwork</h1>
        <p class="subtitle">Talk to your diary, get SMS reminders</p>

        <div class="setup-section" id="setupSection">
            <h3>üì± SMS Setup</h3>
            <p>Enter your Twilio credentials and phone number:</p>
            <div class="form-group"><label for="twilioSid">Twilio Account SID:</label><input type="password" id="twilioSid" placeholder="ACxxxxxxxxxxxxxxxxxxxxxxxx" /></div>
            <div class="form-group"><label for="twilioToken">Twilio Auth Token:</label><input type="password" id="twilioToken" placeholder="Your secret auth token" /></div>
            <div class="form-group"><label for="twilioFrom">Twilio Phone Number:</label><input type="tel" id="twilioFrom" placeholder="+15017122661" /></div>
            <div class="form-group"><label for="phoneNumber">Your Phone Number (to receive SMS):</label><input type="tel" id="phoneNumber" placeholder="+61412345678" /></div>
            <button class="save-config-btn" id="saveBtn">Save & Enable App</button>
        </div>

        <div id="mainApp" class="hidden">
            <button id="voiceBtn" class="voice-button"><span id="btnText">üéôÔ∏è</span></button>
            <div class="status" id="status">Click microphone to start</div>
            <div class="transcript" id="transcript">Your speech will appear here...</div>
            <div class="extracted-tasks" id="extractedTasks"><h3>üìã Found Reminders:</h3><div id="taskList"></div></div>
            <div class="sms-log" id="smsLog"><h3>üì± SMS Log:</h3><div id="smsMessages"></div></div>
            <div class="diary-entries"><h3>üìñ Recent Entries</h3><div id="entriesList"></div></div>
        </div>

        <div id="errorMsg" class="error-message hidden"><strong>Error:</strong> <span id="errorText"></span></div>
        <div id="successMsg" class="success-message hidden"><span id="successText"></span></div>
    </div>

    <script>
        const BACKEND_URL = 'https://trashpandateamwork.onrender.com';

        let recognition = null;
        let isRecording = false;
        let entries = [];
        let config = {}; // Config will be fresh every time
        let smsMessages = [];
        let finalTranscript = '';

        const setupSection = document.getElementById("setupSection"), mainApp = document.getElementById("mainApp"), voiceBtn = document.getElementById("voiceBtn"), btnText = document.getElementById("btnText"), status = document.getElementById("status"), transcript = document.getElementById("transcript"), extractedTasks = document.getElementById("extractedTasks"), taskList = document.getElementById("taskList"), smsLog = document.getElementById("smsLog"), smsMessagesDiv = document.getElementById("smsMessages"), errorMsg = document.getElementById("errorMsg"), errorText = document.getElementById("errorText"), successMsg = document.getElementById("successMsg"), successText = document.getElementById("successText");
        
        function initSpeechRecognition() {
            if ('webkitSpeechRecognition' in window) { recognition = new webkitSpeechRecognition(); } 
            else if ('SpeechRecognition' in window) { recognition = new SpeechRecognition(); } 
            else { showError('Speech recognition not supported. Please use Safari or Chrome.'); return false; }
            
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-AU';

            recognition.onstart = function() {
                console.log("Speech recognition started");
                isRecording = true;
                voiceBtn.classList.add('recording');
                btnText.textContent = '‚èπÔ∏è';
                status.textContent = 'Recording... tap to stop';
                hideMessages();
                showSuccess('Listening... speak now!');
            };
            
            recognition.onresult = function(event) {
                let interimTranscript = '';
                let currentFinal = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        currentFinal += event.results[i][0].transcript;
                    } else {
                        interimTranscript += event.results[i][0].transcript;
                    }
                }
                finalTranscript += currentFinal;
                transcript.innerHTML = `<strong>‚úÖ Final:</strong> ${finalTranscript}<br><em>üé§ Current:</em> ${interimTranscript}`;
            };

            recognition.onend = function() {
                console.log("Speech recognition ended.");
                isRecording = false;
                voiceBtn.classList.remove('recording');
                btnText.textContent = 'üéôÔ∏è';
                status.textContent = 'Click microphone to record again';
                if (finalTranscript.trim()) {
                    console.log("Processing final transcript:", finalTranscript);
                    transcript.classList.add('has-content');
                    processTranscript(finalTranscript.trim());
                } else {
                    console.log("No final transcript to process.");
                }
            };
            
            recognition.onerror = function(event) {
                console.error('Speech recognition error:', event.error);
                if (isRecording) stopRecording();
            };
            return true;
        }

        function showError(msg) { errorText.textContent = msg; errorMsg.classList.remove('hidden'); successMsg.classList.add('hidden'); }
        function showSuccess(msg) { successText.textContent = msg; successMsg.classList.remove('hidden'); errorMsg.classList.add('hidden'); }
        function hideMessages() { errorMsg.classList.add('hidden'); successMsg.classList.add('hidden'); }

        async function saveConfig() {
            config = { twilioSid: document.getElementById('twilioSid').value.trim(), twilioToken: document.getElementById('twilioToken').value.trim(), twilioFrom: document.getElementById('twilioFrom').value.trim(), phoneNumber: document.getElementById('phoneNumber').value.trim() };
            if (!config.twilioSid || !config.twilioToken || !config.twilioFrom || !config.phoneNumber) return showError("Please fill in all fields");
            showSuccess("Credentials accepted! Loading app...");
            setTimeout(() => { hideMessages(); showMainApp(); }, 1500);
        }

        function showMainApp() {
            setupSection.classList.add('hidden');
            mainApp.classList.remove('hidden');
            voiceBtn.classList.add('enabled');
            status.textContent = 'Click microphone to start recording';
            if (initSpeechRecognition()) {
                updateSMSLog();
                updateEntriesDisplay();
            }
        }

        function toggleRecording() {
            if (!recognition) { showError('Speech recognition not initialized.'); return; }
            if (isRecording) { stopRecording(); } else { startRecording(); }
        }
        
        // ########## THIS IS THE CORRECTED FUNCTION ##########
        function startRecording() {
            if (recognition && !isRecording) {
                finalTranscript = ''; // The transcript is now cleared ONLY when you start a new recording.
                try {
                    recognition.start();
                } catch (e) {
                    console.error("Could not start recording:", e);
                }
            }
        }
        
        function stopRecording() { if (recognition && isRecording) { recognition.stop(); } }

        function processTranscript(text) {
            const entry = { id: Date.now(), text: text, date: (new Date).toLocaleString(), tasks: extractTasks(text) };
            entries.unshift(entry);
            updateEntriesDisplay();
            if (entry.tasks.length > 0) {
                displayTasks(entry.tasks);
                extractedTasks.classList.add('show');
                autoSendImportantReminders(entry.tasks);
                showSuccess(`Found ${entry.tasks.length} reminders.`);
                status.textContent = `Found ${entry.tasks.length} reminders!`;
            } else {
                showSuccess('Entry saved! No reminders found.');
                status.textContent = 'Entry saved. No reminders found.';
            }
            setTimeout(hideMessages, 3000);
        }

        function parseScheduledTime(text) {
            const lowerText = text.toLowerCase(), now = new Date;
            if (lowerText.includes('tomorrow')) { const d = new Date(now); d.setDate(now.getDate() + 1); d.setHours(9, 0, 0, 0); return d; }
            if (lowerText.includes('tonight')) { const d = new Date(now); d.setHours(19, 0, 0, 0); return d; }
            const match = lowerText.match(/(?:at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)?/);
            if (match) {
                const scheduledTime = new Date(now);
                let hours = parseInt(match[1]);
                const minutes = parseInt(match[2] || 0), ampm = match[3];
                if (ampm === 'pm' && hours !== 12) hours += 12;
                if (ampm === 'am' && hours === 12) hours = 0;
                scheduledTime.setHours(hours, minutes, 0, 0);
                if (scheduledTime < now) scheduledTime.setDate(now.getDate() + 1);
                return scheduledTime;
            }
            return null;
        }

        function extractTasks(text) {
            const tasks = [];
            const patterns = [
                { regex: /(?:need to|have to|must|should|gotta|got to)\s+([^.!?]+)/gi, type: 'task', priority: 'medium' },
                { regex: /(?:remember to|don't forget to|remind me to)\s+([^.!?]+)/gi, type: 'reminder', priority: 'high' }
            ];
            patterns.forEach(pattern => {
                let match;
                pattern.regex.lastIndex = 0;
                while ((match = pattern.regex.exec(text)) !== null) {
                    if (match && match[1]) {
                        tasks.push({ text: match[0].trim(), type: pattern.type, priority: pattern.priority, extracted: match[1].trim(), scheduledTime: parseScheduledTime(match[0]), id: Date.now() + Math.random() });
                    }
                }
            });
            return tasks;
        }

        function displayTasks(tasks) {
            taskList.innerHTML = "";
            tasks.forEach(task => {
                const taskElement = document.createElement('div');
                taskElement.className = 'task-item';
                const priorityEmoji = task.priority === 'high' ? 'üî•' : 'medium' === '‚ö°' ? 'üìù' : '';
                let scheduleInfo = '';
                if (task.scheduledTime) scheduleInfo = `<br><small>‚è∞ Scheduled for: ${task.scheduledTime.toLocaleString()}</small>`;
                taskElement.innerHTML = `<div><strong>${priorityEmoji} ${task.type}:</strong> ${task.extracted}<br><small>From: "${task.text}"</small>${scheduleInfo}<br><button class="send-sms-btn" data-task-id="${task.id}">Send SMS Now</button></div>`;
                taskList.appendChild(taskElement);
            });
            taskList.querySelectorAll('.send-sms-btn').forEach(btn => btn.addEventListener('click', function() { sendTaskSMS(this.getAttribute('data-task-id')); }));
        }

        function autoSendImportantReminders(tasks) { tasks.forEach(task => { if (task.priority === 'high' || task.type === 'urgent') setTimeout(() => sendTaskSMS(task.id, true), 1000); }); }

        async function sendTaskSMS(taskId, auto = false) {
            const task = findTaskById(taskId);
            if (!task) return;
            const message = `ü¶ù Trash Panda Reminder: ${task.extracted}`;
            const buttons = taskList.querySelectorAll(`[data-task-id="${taskId}"]`);
            buttons.forEach(btn => { btn.textContent = "Sending..."; btn.disabled = true; });
            try {
                const response = await fetch(`${BACKEND_URL}/send-sms`, { method: 'POST', headers: { "Content-Type": "application/json" }, body: JSON.stringify({ twilioSid: config.twilioSid, twilioToken: config.twilioToken, twilioFrom: config.twilioFrom, phoneNumber: config.phoneNumber, message: message }) });
                const result = await response.json();
                if (!response.ok || !result.success) throw new Error(result.error || "Unknown server error");
                console.log("Server confirmed SMS sent:", result.sid);
                logSMSMessage(message, auto ? "auto-sent (Real)" : "manual-sent (Real)");
                if (!auto) showSuccess("Real SMS sent successfully!");
                buttons.forEach(btn => { btn.textContent = "Sent!"; });
            } catch (error) {
                console.error("Error sending SMS:", error);
                showError(`Failed to send SMS: ${error.message}`);
                logSMSMessage(`Failed: ${message}`, "failed");
                buttons.forEach(btn => { btn.textContent = "Send SMS Now"; btn.disabled = false; });
            } finally {
                updateSMSLog();
                if (!auto) setTimeout(hideMessages, 3000);
            }
        }

        function findTaskById(taskId) { for (let entry of entries) { const task = entry.tasks.find(t => t.id == taskId); if (task) return task; } return null; }
        function logSMSMessage(message, status) { smsMessages.unshift({ message, status, timestamp: (new Date).toLocaleString() }); updateSMSLog(); }

        function updateSMSLog() {
            if (smsMessages.length === 0) { smsLog.classList.remove('show'); return; }
            smsLog.classList.add('show');
            smsMessagesDiv.innerHTML = "";
            smsMessages.slice(0, 10).forEach(sms => {
                const smsElement = document.createElement('div');
                smsElement.className = 'sms-message';
                const statusEmoji = sms.status === 'auto-sent (Real)' ? 'ü§ñ' : 'üë§';
                smsElement.innerHTML = `<strong>${statusEmoji} ${sms.timestamp}</strong><br>${sms.message}`;
                smsMessagesDiv.appendChild(smsElement);
            });
        }

        function updateEntriesDisplay() {
            const entriesList = document.getElementById('entriesList');
            entriesList.innerHTML = "";
            entries.slice(0, 5).forEach(entry => {
                const entryElement = document.createElement('div');
                entryElement.className = 'diary-entry';
                entryElement.innerHTML = `<div class="entry-date">${entry.date}</div><div>${entry.text}</div>` + (entry.tasks.length > 0 ? `<small>üìù ${entry.tasks.length} reminders found</small>` : "");
                entriesList.appendChild(entryElement);
            });
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            const saveButton = document.getElementById('saveBtn');
            const voiceButton = document.getElementById('voiceBtn');

            if (saveButton) saveButton.addEventListener('click', saveConfig);
            if (voiceButton) voiceButton.addEventListener('click', toggleRecording);
        });
    </script>
</body>
</html>
